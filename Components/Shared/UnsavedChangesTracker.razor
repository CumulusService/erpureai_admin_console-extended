@using AdminConsole.Services
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject IUnsavedChangesService UnsavedChangesService
@inject IModalService ModalService
@inject NavigationManager Navigation

@code {
    [Parameter] public string FormId { get; set; } = string.Empty;
    [Parameter] public string WarningMessage { get; set; } = "You have unsaved changes. Are you sure you want to leave without saving?";
    [Parameter] public bool TrackChanges { get; set; } = false;
    [Parameter] public EventCallback<bool> OnUnsavedChangesChanged { get; set; }
    [Parameter] public string UserRole { get; set; } = "User";
    [Parameter] public string Context { get; set; } = "Form";

    private bool _isInitialized = false;
    private bool _isDisposed = false;
    private bool _enableEnhancedMode = true;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized)
        {
            _isInitialized = true;
            
            // Subscribe to navigation changes
            Navigation.LocationChanged += HandleLocationChanged;
            
            // Subscribe to unsaved changes service events
            UnsavedChangesService.UnsavedChangesChanged += HandleUnsavedChangesChanged;
            
            await UpdateJavaScriptState();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isInitialized && !_isDisposed)
        {
            await UpdateJavaScriptState();
        }
    }

    private async Task UpdateJavaScriptState()
    {
        try
        {
            // DISABLED: JavaScript unsaved changes detection completely removed
            System.Diagnostics.Debug.WriteLine("UpdateJavaScriptState: DISABLED - no browser notifications");
            
            // Always disable JavaScript tracking to prevent browser notifications
            await JSRuntime.InvokeVoidAsync("unsavedChanges.disable");
            System.Diagnostics.Debug.WriteLine("Forced unsavedChanges.disable to prevent browser notifications");
        }
        catch (Exception ex)
        {
            // Handle JavaScript interop errors gracefully and try fallback
            System.Diagnostics.Debug.WriteLine($"JavaScript interop error in UnsavedChangesTracker: {ex.Message}");
            _enableEnhancedMode = false; // Disable enhanced mode on error
            
            // Try basic fallback
            try
            {
                var shouldTrack = TrackChanges && UnsavedChangesService.HasUnsavedChanges();
                if (shouldTrack)
                {
                    await JSRuntime.InvokeVoidAsync("unsavedChanges.enable", WarningMessage);
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("unsavedChanges.disable");
                }
            }
            catch
            {
                // If even basic fallback fails, log and continue
                System.Diagnostics.Debug.WriteLine("Even basic JavaScript fallback failed");
            }
        }
    }

    private string GetContextualWarningMessage()
    {
        if (!string.IsNullOrEmpty(WarningMessage) && WarningMessage != "You have unsaved changes. Are you sure you want to leave without saving?")
        {
            return WarningMessage; // Use custom message if provided
        }

        // Generate contextual message based on role and context
        var roleContext = UserRole.ToLowerInvariant() switch
        {
            "superadmin" => "admin configuration",
            "orgadmin" => "organization settings",
            "developer" => "agent configuration",
            _ => "form data"
        };

        var actionContext = Context.ToLowerInvariant() switch
        {
            "invitation" => "invitation details",
            "usermanagement" => "user management changes",
            "settings" => "settings",
            "agenttype" => "agent type configuration",
            _ => "form changes"
        };

        return $"You have unsaved {actionContext}. Are you sure you want to leave without saving your {roleContext}?";
    }

    public async Task MarkAsChanged()
    {
        if (!string.IsNullOrEmpty(FormId))
        {
            UnsavedChangesService.MarkFormAsChanged(FormId);
            await UpdateJavaScriptState();
            await OnUnsavedChangesChanged.InvokeAsync(true);
        }
    }

    public async Task MarkAsSaved()
    {
        if (!string.IsNullOrEmpty(FormId))
        {
            UnsavedChangesService.MarkFormAsSaved(FormId);
            await UpdateJavaScriptState();
            await OnUnsavedChangesChanged.InvokeAsync(false);
        }
    }

    public async Task<bool> ConfirmNavigation(string? customMessage = null)
    {
        // DISABLED: Browser notifications completely removed - always allow navigation
        System.Diagnostics.Debug.WriteLine("ConfirmNavigation: Browser notifications DISABLED - allowing navigation");
        return true;

        try
        {
            // Use the modern modal service instead of JavaScript alerts
            var result = await ModalService.ShowUnsavedChangesAsync(Context, UserRole);
            
            // If user chose to leave without saving, disable tracking
            if (result)
            {
                await MarkAsSaved();
            }
            
            return result;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"ConfirmNavigation error: {ex.Message}");
            
            // Fallback to JavaScript confirmation if modal service fails
            try
            {
                var message = customMessage ?? GetContextualWarningMessage();
                return await JSRuntime.InvokeAsync<bool>("unsavedChanges.confirmNavigation", message);
            }
            catch
            {
                // Ultimate fallback - assume user wants to stay for safety
                System.Diagnostics.Debug.WriteLine("ConfirmNavigation: All confirmation methods failed, blocking navigation for safety");
                return false;
            }
        }
    }


    private async void HandleLocationChanged(object? sender, Microsoft.AspNetCore.Components.Routing.LocationChangedEventArgs e)
    {
        if (_isDisposed) return;

        // Clear unsaved changes when successfully navigating away
        // Note: This only fires after navigation is confirmed/completed
        if (!string.IsNullOrEmpty(FormId))
        {
            UnsavedChangesService.MarkFormAsSaved(FormId);
        }
        
        await UpdateJavaScriptState();
    }

    private async void HandleUnsavedChangesChanged(object? sender, UnsavedChangesEventArgs e)
    {
        if (_isDisposed) return;

        await InvokeAsync(async () =>
        {
            await UpdateJavaScriptState();
            await OnUnsavedChangesChanged.InvokeAsync(UnsavedChangesService.HasUnsavedChanges());
            StateHasChanged();
        });
    }

    public void Dispose()
    {
        if (!_isDisposed)
        {
            _isDisposed = true;
            
            // Unsubscribe from events
            Navigation.LocationChanged -= HandleLocationChanged;
            UnsavedChangesService.UnsavedChangesChanged -= HandleUnsavedChangesChanged;
            
            // Clean up this form's unsaved changes
            if (!string.IsNullOrEmpty(FormId))
            {
                UnsavedChangesService.MarkFormAsSaved(FormId);
            }

            // Update JavaScript state with force disable
            try
            {
                if (_enableEnhancedMode)
                {
                    _ = JSRuntime.InvokeVoidAsync("unsavedChanges.forceDisable");
                }
                else
                {
                    _ = JSRuntime.InvokeVoidAsync("unsavedChanges.disable");
                }
            }
            catch
            {
                // Ignore errors during dispose
            }
        }
    }
}